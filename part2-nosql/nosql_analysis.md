# NoSQL Analysis for FlexiMart Product Catalog (MongoDB)

## Section A: Limitations of RDBMS
A relational database works best when entities share a stable, uniform structure. A product catalog becomes difficult in an RDBMS when different product types require different attributes (e.g., laptops need RAM/processor, shoes need size/color). In MySQL, supporting this usually forces either (1) many nullable columns that are mostly empty, or (2) multiple subtype tables with frequent JOINs, increasing complexity and slowing development. Schema changes are also costly: adding a new product type often requires ALTER TABLE operations, migrations, and updates across application logic. Reviews are another pain point: reviews are naturally a nested, one-to-many structure with metadata (rating, comment, date). In an RDBMS this becomes extra tables (product_reviews, review_users, etc.), requiring joins for common read patterns like “show product with reviews,” which adds query complexity and performance overhead at scale.

## Section B: NoSQL Benefits 
MongoDB fits a diverse product catalog because it supports a flexible document model. Each product can store only the fields it needs, so a laptop document can include processor/RAM, while a shoe document includes sizes/colors—without changing a global schema. This reduces migrations and makes adding new product types faster. MongoDB also supports embedded documents and arrays, which is ideal for reviews: reviews can be stored inside the product document as an array of subdocuments. This matches how applications read data (one product page = product + specs + reviews) and reduces expensive joins. MongoDB scales horizontally using sharding, which helps when product catalog size and traffic grow (more products, more reviews, more reads). For analytics like average rating per product or average price per category, MongoDB’s aggregation pipeline provides expressive, server-side computation over nested data.

## Section C: Trade-offs
Two disadvantages of MongoDB versus MySQL are consistency and data duplication. In relational systems, constraints and joins enforce strong referential integrity across tables; MongoDB typically relies more on application-level integrity, especially when data is embedded. Second, embedding improves read performance but can duplicate data (e.g., repeating category or brand fields), which increases storage and can create update complexity if duplicated values must be kept consistent. Additionally, complex cross-entity queries (true relational joins across many collections) are generally more natural and simpler in SQL than in a document database.
